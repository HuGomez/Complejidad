{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Complejidad en algoritmos de ordenamiento","tagline":"Proyecto para mostrar la importancia de la complejidad algorítmica en la Ingeniería de Sistemas","body":"##Complejidad\r\n\r\nPara calcular la complejidad algorítmica se tienen en cuenta ciertos factores como el lenguaje, la máquina y el algoritmo utilizados. Para lo anterior se piden ciertas pruebas con una cantidad determinada de entradas, implementando los siguientes algoritmos:\r\n\r\n1. Bubble Sort.\r\n2. Insertion Sort.\r\n3. Heap Sort.\r\n4. Quick Sort.\r\n5. Counting Sort.\r\n\r\n##Análisis\r\n\r\n**Eficiencia de Tiempo**\r\n\r\nPara cada una de los algoritmos se deberá calcular la complejidad temporal (el tiempo de ejecución). Luego se debe ejecutar cada algoritmo implementado con diferentes tamaños de entradas, tomando las medidas de tiempo de ejecución para cada uno. Esto implicará generar un número grande de ejemplos de prueba, al azar y guardarlos en un archivo, para poder probar todas los algoritmos de ordenamiento con los mismos datos\r\nde entrada. El análisis debe estar contenido en una tabla donde, para cada algoritmo, se tomen muestras de diferentes tamaños (unas dos o tres muestras por cada n).\r\n\r\n**Números a ordenar**\r\n\r\nEste proyecto está destinado a ordenar números enteros sin signo generados aleatoriamente entre 0 (cero) y 6’000.000 (seis millones).\r\n\r\n**Tamaños de las entradas para todos los algoritmos**\r\n\r\nTodos los algoritmos de ordenamiento se tienen que probar con entradas de tamaño:\r\n\r\nPara algoritmos de complejidad Θ(n^2): 20.000, 40.000, 60.000, 80.000, ... , 300.000.\r\n\r\nPara el resto de algoritmos: 100.000, 200.000, 300.000, 400.000, ... , 1’500.000.\r\n\r\nEl tiempo se debe medir en milisegundos (ms).\r\n\r\n**Inferir tiempos de ejecución esperados**\r\n\r\nCon los factores constantes calculados, estimar el tiempo de ejecución para entradas de tamaño:\r\n\r\nPara algoritmos de complejidad Θ(n^2): 30.000, 50.000, 70.000, 90.000, ... , 310.000.\r\n\r\nPara el resto de algoritmos: 150.000, 250.000, 350.000, 450.000, ... , 1’550.000.\r\n\r\nLuego se debe correr el algoritmo con estas tallas y tomar el tiempo real de ejecución. La comparación entre los tiempos estimados y los tiempos reales de ejecución debe ser parte del informe.\r\n\r\nLuego se debe estimar cuanto tiempo les tomaría a los algorimos ordenar arreglos de tamaño: 30’000.000, 40’000.000, 60’000.000, ... , 200’000.000.\r\n\r\n##Autores\r\nHugo Andrés Gómez @cauchoroto\r\nDouglas Hernández @fullarukad"}